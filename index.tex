\documentclass[
        twocolumn,german,biblatex
    ]{article}

\input{trendsstyle.tex}


\pagestyle{empty}


\newcommand{\stt}{Soft\-ware\-tech\-nik-Trends}


\newcommand{\BI}{\begin{itemize}}


\newcommand{\EI}{\end{itemize}}


\raggedbottom

\usepackage[style=lni,]{biblatex}

\addbibresource{my-paper.bib}


% Standard packages
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{array}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{colortbl}
\usepackage{pdflscape}
\usepackage{tabularx}
\usepackage{threeparttable}
\usepackage{threeparttablex}
\usepackage[normalem]{ulem}
\usepackage{makecell}
\usepackage{framed} % Needed for code blocks
\usepackage{orcidlink}
\usepackage{authblk}


% configure hyperlinks
\hypersetup{pdfborder = { 0 0 0 }}

% solve \tightlist error
\providecommand{\tightlist}{%
    \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

% solve \pandocbounded error
\providecommand{\pandocbounded}[1]{#1}

\renewcommand\Authands{\normalfont\small \ and }
\renewcommand\Authfont{\scshape\small}
\renewcommand\Affilfont{\normalfont\footnotesize}


% rewrite longtable command to fit 2-columns

\makeatletter
\let\oldlt\longtable
\let\endoldlt\endlongtable

\def\longtable{\@ifnextchar[\longtable@i \longtable@ii}
\def\longtable@i[#1]{\begin{figure}[t]
\onecolumn
\begin{minipage}{0.5\textwidth}
\oldlt[#1]
}
\def\longtable@ii{\begin{figure}[t]
\onecolumn
\begin{minipage}{0.5\textwidth}
\oldlt
}
\def\endlongtable{\endoldlt
\end{minipage}
\twocolumn
\end{figure}}
\makeatother
\title{Research Software Engineering for Natural Sciences}
  \author[]{ \orcidlink{}}
  \affil[]{}
  \author[]{ \orcidlink{}}
  \affil[]{}
  \author[]{ \orcidlink{}}
  \affil[]{}
  \author[]{ \orcidlink{}}
  \affil[]{}
  \author[]{ \orcidlink{}}
  \affil[]{}
  \author[]{ \orcidlink{}}
  \affil[]{}
  \author[]{ \orcidlink{}}
  \affil[]{}
  \author[]{ \orcidlink{}}
  \affil[]{}
\date{}


\begin{document}
    \maketitle



% Body
    \section{Introduction}\label{introduction}

    The term Research Software Engineer (RSE) has become a label for
    specific technical job roles in universities and research
    institutions. It relates to people doing work that includes elements
    of traditional software engineering but also rests on a broad
    spectrum of skills from neighbouring domains such as scientific
    computing, data science, research data management, and the open
    science movement in general including skills that have not been
    packaged into elements of established curricula in formal education
    yet.

    Software engineering as a discipline has evolved, over the past four
    decades, into a mature field with a rich tool set as well as a large
    body of knowledge that includes methods, theory, codes of practice
    and well developed sub-fields. Established curricula in degree
    programs produce practitioners of a well defined engineering
    profession.

    Although researchers have used computers in scientific work since
    the dawn of the computing era, the formal role of Research Software
    Engineer (RSE) has only recently been recognized. Nevertheless, the
    RSE community largely comprises individuals without formal education
    in software engineering. However, it has been realized that the
    increasing importance of computational science, complexity, demands,
    size of teams, number of collaboration partners and generally the
    need for more ambitious software projects calls for a better and
    more systematic reuse of knowledge and skills from software
    engineering. This is especially true for natural sciences (from here
    on ``sciences''), where RSEs' expertise often focuses on very
    specialized technical problem-solving in close conjunction with a
    specific research question at the expense of the mastery of more
    general concepts of software engineering.

    A disconnect between scientific computing and software engineering
    practitioners and communities has been already observed by others
    including \textcite{Kelly2007}. We aim to improve the situation in
    the spirit of her conclusion, which urges the scientific community
    to better apply the current solutions offered by the software
    engineering community and the latter to better cater to the sciences
    as an application domain. Thus, the idea of introducing a master
    curriculum for research software engineering for natural sciences
    was born. Establishing this formal training in Research Software
    engineering(RSEng) will raise specialists that can fill a vacuum for
    computational specialists in the sciences. On the one hand, those
    RSEs should be firmly grounded in software engineering and assume
    practices and the mindset of a software engineer. On the other hand,
    these RSEs should develop a deep understanding of computational
    scientific work and the relevant methods and practices. They should
    assume a specific professional identity that also includes the
    self-image of a scientist with the associated values and practices,
    functions and is recognized as an equal member of a domain research
    team.

    Then we have to ask, what is the identity needed for students to be
    accepted and feel as qualified software engineers but also be
    intellectually connected to the natural sciences? In other words:
    what is the special relationship between natural sciences and
    computing historically, and how does it relate to software
    engineering foundations?

    Historically, natural sciences and software engineering share common
    threads in the fabric of their identities, but different challenges
    in the past decades have led to an estrangement between the fields.
    Today students of one field can not easily cross over into the other
    field and contribute their knowledge, due to the different domain
    identities that have been forged.

    We argue that it is not enough to augment a software engineering
    curriculum with a specialization in a natural science or to add or
    improve the computer programming modules in a science curriculum. We
    propose that it is necessary to create a set of new disciplines that
    more fundamentally fuse software engineering with a natural science.
    A discipline of this kind, e.g.~``Research Software Engineering in
    geoscience'', should be more than a combination of both fields. It
    should rather assume its own distinct identity and generate new
    research questions, new methods to address them, and a new type of
    expert to substantially re-shape and advance relevant scientific
    sub-domains, e.g.~climate system modeling. This goal should form the
    basis for creating new master's programs that lay the foundation for
    students to assume a professional identity as Research Software
    Engineers in Science. It should make them qualified Software
    Engineers as well as fully accepted scientists in a natural science,
    who feel at home in both domains.

    In order to expose this identity to the reader, the paper is
    structured as follows. We will first trace back the history of the
    natural sciences and computing. After that we will give a view on
    the history of software engineering as it relates to research.
    Arriving at the present, we shine a light on how software is
    currently developed in academia, before considering larger trends
    and challenges, that will shape software development for research in
    the near future. From this we synthesize a common core that should
    be the identity of a research software engineer in science, before
    we detail how this ideal identity of a research software engineer
    informs the planned curriculum for research software engineering.

    \section{Related work and programs}\label{related-work-and-programs}

    Similar efforts were carried out in allied communities and have
    yielded tailored curricula, such as the RSE-HPC curriculum
    \autocite{Filinger2025} by the UNIVERSE-HPC project, the RSE
    curriculum track for computational scientists and engineers
    \autocite{Chourdakis2025} at the Technical University of Munich, the
    Simulation Software Engineering course \autocite{Uekermann2021} at
    the University of Stuttgart, or the Bachelor's and Master's program
    ``Simulation Technology'' from the Cluster of Excellence
    ``Data-Integrated Simulation Science (SimTech)''
    \autocite{SimTech2019} for computer science students. In addition,
    there's experiences from teaching Research Software Engineering
    Courses at four German universities in different masters programs
    described by Bertrand et al. \autocite{Bertrand2025}. An RSE for
    Natural Sciences curriculum would help professionalize RSE career
    paths in natural sciences, while also addressing the specific needs
    of scientists, such as accumulating enough academic credit
    (e.g.~through their graduate school) in natural sciences to be able
    to enroll in a Ph.D.~program in a STEM field.

    \section{Science and Computing: Common
    History}\label{science-and-computing-common-history}

    \emph{Here we explain, why Natural sciences and means of computation
    are linked }

    TODO: check if the content is still valid after rephrasing it with
    AI for the purpose of this paper:

    Ever since early astronomy, humans have used computation to quantify
    and predict nature. To help with these tasks, humans also invented
    practical tools like water clocks and the abacus as well as
    theoretical tools and concepts, like the hindu-arabic decimal system
    or binary numbers. Some of these theoretical concepts become
    complete subfields such as Algebra, which was introduced as al-jabr
    by the persian astronomer al-Khwarizmi, whose name incidentally is
    also the origin of the word algorithm.

    In a sort of virtuous cycle, advancements in science lead to
    advancements in engineering and manufacturing, allowing for the
    construction of increasingly complex computational machines, which
    in turn enabled further scientific discoveries. These computing
    machines range from mechanical devices like the Pascaline or the
    Analytical Engine \autocite{bromley2008charles}, over
    electro-mechanical machines like Zuse's Z3 \autocite{Zuse1986}, or
    the British COLOSSUS \autocite{Copeland2004} to the fully electronic
    machines that are ubiquitous today.

    Starting with high-level programming languages like FORTRAN by John
    Backus and his team at IBM \autocite{Backus1978}, scientists have
    been enabled to express algorithms independently of hardware,
    transforming how they interacted with computation.

    The rapid increase in computing capabilities, together with
    advancements in mathematical modeling and scientific software, has
    lead a high fidelity of simulation results. Consequently, so called
    in silico experiments are becoming a valid alternative for many in
    vivo or in vitro experiments.

    Computation, in the modern sense of computer-aided work, has since
    permeated nearly every field of natural science, often giving rise
    to entire sub-disciplines, such as computational astrophysics,
    bioinformatics, computer-aided pharmacy, and earth system
    simulation.

    Today, at least some computational skills are needed in most fields
    of natural sciences. The development of computational tools is not
    just a support activity; it defines how science is practiced,
    scaled, and extended.

    \section{Software Engineering and Research Applications:
    Divergence}\label{software-engineering-and-research-applications-divergence}

    \emph{Here we explain, where Software Engineering comes from, and
    where and why it deviated from its co-development with science}

    After the second World War the Apollo Program was a major driver in
    enhancing the quality of mission-critical software. (TODO: We could
    mention Margaret Hamilton, as the first person identifying herself
    as a ``software engineer''.) In this setting the term `software
    engineering' was coined\autocite{Randell1979} and two well-known
    NATO conferences were held in 1968\autocite{Naur1969} and
    1969\autocite{Buxton1970} to discuss how to keep software projects
    reliable and in time. While good programming practices were already
    circulating as soon as 1961\autocite{Hosier1961}, these NATO
    conferences shed light on the `software
    crisis'\autocite{Randell1979}. Adoption of best coding practices was
    slow\autocite{Boehm1979}, with calls to reform not just programming
    techniques but also programming
    culture\autocite{Weinberg1971,Boehm1979}, e.g.~by promoting software
    documentation and teamwork over lone coders with full knowledge of
    the codebase\autocite[100]{Weinberg1971} (with an early
    formulation\autocite[114]{Weinberg1971} of what is now known as the
    `bus factor'\autocite{Zazworka2010,Jabrayilzade2022}). The notion of
    the quality and reliability of software continued to be a driving
    force of software engineering with the ever-increasing use of
    software in safety-critical systems (e.g.~medicine or aviation),
    which meant that software could kill, in the 70s and 80s. The next
    big projects was the development of modern general purpose operating
    systems in the late 80s, which combined with affordable personal
    computers, helped democratize the use and development of research
    software for lab instrument control, data acquisition, and
    statistical analysis\autocite{Robinson1984}. The advent of the
    Internet added another level of complexity, since new modes of
    operation for software across multiple computers are possible. In
    2005, the Software Engineering Body of Knowledge (SWEBOK) was
    created to document foundational competencies of
    SEs\autocite{SWEBOK2005} and design academic
    curricula\autocite{Fairley2014}.

    In the 2000s, the SE community identified a special case of software
    users nicknamed `professional end-user
    developers'\autocite{Segal2005,Segal2007,Segal2009b}. Most of the
    interviews were conducted with scientists and revealed the
    difficulties of reconciling research practices with software
    engineering
    practices\autocite{Segal2005,Segal2009,Lawrence2006,Wood2003,Storer2017}.
    In parallel, science communities also identified a new role centered
    around research software\autocite{Baxter2006}, although the term
    `research software engineer' wouldn't be coined until
    2012\autocite{Baxter2012}.

    \section{Research Software Engineering for Natural Sciences:
    Convergence}\label{research-software-engineering-for-natural-sciences-convergence}

    Since the ``birth'' of software engineering at the NATO conference
    in 1969 \autocite{Naur1969}, the communities of software engineering
    (SE) and scientific computing --- now referred to as research
    software engineering (RSE) --- have largely evolved along separate
    paths. The SE community, much like computer science as a whole, has
    focused almost exclusively on business and embedded software
    \autocite{Johanson2018}. Nevertheless, there is much that the RSE
    community can learn from and adopt within software engineering
    practices. Conversely, the research software engineering (RSEng)
    opens up a new field of research for the SE community nowadays
    referred to as RSE research \autocite{Felderer2025}.

    There are certain influencing factors that have developed
    differently over time, causing classical software engineering and
    computing for the sciences drifting apart. These differences can be
    illustrated with (at least three) structural dichotomies: - fast
    prototyping (short term) vs.~long-term software growth -
    internalized knowledge vs.~externalized knowledge -
    mathematically-driven modelling vs.~human-driven modelling

    Most research in academia {[}find citation that shows 70\% of output
    is generated by PhDs{]} is usually driven by individuals that often
    do their research in order to a achieve a personal qualification
    goal, such as a PhD. This leads to a set of intermingling goals. On
    the one hand there is the personal qualification goal, that has to
    be achieved in a given timeframe in order to advance in the career.
    On the other hand, the institution has its own long-term goals and
    must cope with the high fluctuation rate of researchers. Also, the
    scientific academic culture in general is characterized by a rapidly
    changing environment and frequent publication pressure. This web of
    goals leads to certain aspects that are peculiar to software
    development in academia, such as frequent turnover of developers,
    limited long-term maintenance, and a focus on producing quick
    results for publications rather than building robust, reusable
    software.

    In particular, software is often developed and maintained only
    during a single PhD project. Hence, the development is mostly
    research-oriented. Therefore the software often remains in the
    prototype stage instead of prototyping in order to prepare a
    blueprint that a larger team of engineers can use to build a
    well-designed and sound product. Often this results in a duplication
    of effort or ``reinventing the wheel'' \autocite{Smith2024}. To
    counteract this trend, funding agencies have created incentives to
    consolidate fragmented domain codes by prioritizing research
    software that is easily extensible and re-usable in different
    contexts with minimally-invasive adaptations \autocite{DFG2022RSE}.

    Academic software development operates in rapidly changing
    environments and therefore requires flexible processes. In
    principle, this aligns well with agile methods. However, agile
    methodologies are typically taught and tooled for larger,
    industry-style teams (e.g., Scrum, Kanban, \ldots). In research
    contexts---often small, transient, or even single-developer
    teams---these practices need careful adaptation. Incorporating
    lightweight, research-appropriate agile workflows, supported by
    professional software engineering expertise, should be a core
    element of an RSE for Natural Sciences curriculum. More generally,
    this illustrates that SE techniques cannot be transferred into
    research settings without thoughtful adaptation and opens room for
    RSE research.

    In addition, the ongoing digitalization of society and of science in
    particular has reshaped the scientific ecosystem, making a
    reevaluation of this separation necessary. Certain progresses, and
    also the way how science is conducted and organized have incurred
    the need to incorporate practices from software engineering that
    hitherto have been neglected.

    In the past, it was considered ``good enough'' for software to be
    developed by a single PhD student. However, as research groups have
    grown, there is now a need for more systematic approaches to
    workflows and team organization. Previously, software was often
    developed as a by-product of scientific work and was rarely made
    explicit in grant proposals. However, with the increasing reliance
    of science on software, funding agencies have changed their
    requirements: software development must now be transparent,
    documented, and tracked to justify funding and quantify development
    costs.

    A recent trend is the growing awareness of the environmental impact
    of scientific computing, which is now being considered in research
    planning \autocite{lannelongue2023}. The increasing availability of
    computing power, especially since the 1990s, has led to a surge in
    research conducted with computers. However, the lack of established
    processes to ensure software quality contributed to the so-called
    ``reproducibility crisis'' \autocite{Pashler2012}. In response,
    there have been increasing demands for reproducible research,
    leading to the formulation of the FAIR principles
    \autocite{Hutton2016,Stagge2019,Stodden2018}.

    While initially much research could be conducted using standard
    commercial software packages with few dependencies, an
    ever-increasing amount of research software now relies on other
    research software. This means that software must provide stable APIs
    and be reliable across multiple versions, placing greater pressure
    on reliability. There have also been cases where buggy software led
    to incorrect scientific conclusions, resulting in what has been
    called the ``credibility crisis''
    \autocite{Miller2006Xray,Smart2018,Miller2016fMRI}.

    Additionally, the trend toward transdisciplinary projects has
    introduced more complex requirements due to a more heterogeneous set
    of stakeholders. Also, the emerging use of large language models in
    software development processes further requires that the latest
    results from software engineering research are taken into account.

    While the historical separation between computing in science and in
    software engineering may seem logical at first glance, the recent
    developments increasingly challenge this divide. Scientific work now
    faces growing demands that align closely with established software
    engineering principles. These include the need for transparent and
    auditable software contributions to justify funding, standardized
    development processes driven by the reproducibility crisis, and an
    emphasis on energy efficiency in response to the climate crisis.
    Furthermore, the growing complexity of research, the rise of
    transdisciplinary collaboration, and the integration of advanced
    technologies like large language models have introduced intricate
    software pipelines across disciplines. Together, these trends
    highlight the convergence of scientific computing and software
    engineering practices.

    Two courses of action suggest themselves. First, trained software
    engineers could be embedded within research projects or domain
    scientists could adopt more software engineering techniques and
    practices.

    We argue that the first option is not a general solution, since,
    generic graduated Software Engineers

    \begin{itemize}
    \tightlist
    \item
      lack the theoretical depth of domain specific knowledge,
    \item
      lack of understanding handling cultural complexities in research
      organizations,
    \item
      and lack experience in dealing with the community in fast changing
      teams
    \end{itemize}

    However, the straight-forward adoption of SE techniques without
    adaptations for the research context also has limitations. E.g.
    software engineering techniques often rely on the use of
    abstractions to achieve modularity, maintainability, and scalability
    in complex systems. On the other hand, in research software, the
    overhead introduced by additional abstraction layers can be
    challenging for developers not familiar with the techniques. Hence,
    the additional complexity sometimes hinder rapid prototyping and
    direct implementation of domain-specific algorithms, especially when
    developer teams are small and focused on immediate scientific goals.

    Another aspect that distinguishes the typical software process
    design from research software engineering is the ambition of
    externalizing all knowledge that is contained in the software. In an
    industrial setting where bottlenecks are a problem and programmers
    need to be replaceable this is an essential factor of effectiveness
    \autocite{gronau2006kmdl}. In the natural sciences, research
    software is often based on state-of-the-art mathematical models that
    are only accessible to very few specialized researchers. Here, the
    question arises if the mathematical model should be considered the
    documentation whereas the software only plays the role of
    proof-of-concept implementations.

    A similar argument could be made for systematics of software
    engineering processes and management. Modelling user behavior
    introduces a set of new complexities that lead to the development of
    management techniques such as agile development that try to expose
    the software to the customers as often as possible in order to adapt
    the software more efficiently to the user. From requirements
    engineering, to prototyping and evaluation, the social sciences and
    psychology have played a role in connecting craftsmanship of an
    engineer to the intricacies of big human teams, customers and
    stakeholders {[}find something that talks about human computer
    interaction and software engineering{]}. Only recently have research
    software teams and research groups grown to an extent that these
    insights are needed {[}todo reference for claim{]}.

    {[}Some SE processes are not applicable in NatSci{]} From
    requirements engineering, to prototyping and evaluation, the social
    sciences and psychology have played a role in connecting
    craftsmanship of an engineer to the intricacies of big human teams,
    customers and stakeholders {[}find something that talks about human
    computer interaction and software engineering.

    {[}Some SE topics should be taken up by RSEs4NatSci unchanged{]}
    SOLID principles, design patterns, \ldots..

    \section{A RSE Master Curriculum}\label{a-rse-master-curriculum}

    Taking the historical trend into consideration it becomes apparent
    that the traditional division of labor between software engineers
    and computational scientists is no longer appropriate for today's
    challenges. As Research Software Engineering starts to combine
    software engineering and science again, thereby reversing the
    historical trend, the question arises which disciplinary identity a
    research software engineer should have.

    We argue that neither additional training in a natural science for
    software engineers nor vice versa would be suited for the
    development of an adequate professional identity. For example an
    SE-curriculum augmented with physics courses within the typical
    timeframe allotted for a master degree will not be sufficient for a
    student to accumulate the exposure, knowledge and experience
    necessary to develop a physicist's identity in addition to her SE
    identity. As \textcite{gomez2025} observe, a new discipline is
    required for a new professional identity acquired through formal
    academic education.

    Similar to data scientists, data stewards and other modern job
    roles, a research engineer for the natural sciences is not a niche
    innovation based on a short-living trend. The newly formed identity
    should encompass key competences from both fields, be rooted in the
    history and culture of both SE and natural sciences while including
    new competencies that arise from the special requirements for
    typical RSE work.

    We proposed a rough outline for a masters curriculum that includes a
    track for Research Software Engineering for Natural Science that is
    suited for students with a Bachelor degree in a natural science. The
    track will be of type 3 of the recommendations of the German
    Computer Society which the domain science having an equal share as
    computer science \autocite{zukunft2016empfehlungen}. A second track
    of type 1 (computer science in the lead) is also planned but is
    secondary to this paper. The current state of the development
    process and corresponding discussions can be found at
    \autocite{RSECurriculums2021}.

    If neither division of labor between software engineers and
    scientists, nor an additive training to be both work conceptually,
    the third option is to develop a new identity and a corresponding
    professional field. Similar to data scientists, data stewards and
    other modern job roles, a research engineer for the natural sciences
    is not a niche innovation based on a short-living trend. The newly
    formed identity should encompass the history, culture and key
    competences from both fields. Based on the above discussion and
    workshops with the RSE-community \autocite{derseev} the curriculum
    should contain these parts:

    \begin{enumerate}
    \def\labelenumi{\arabic{enumi}.}
    \tightlist
    \item
      an identity building group of modules that addresses key RSE
      issues such as \ldots{}

      \begin{itemize}
      \tightlist
      \item
        history of software engineering in science
        \autocite{leroy_when_2021}
      \item
        research software science
        \autocite{felderer_investigating_2025,heroux_research_2022}
      \item
        management and communication in the research context
      \item
        ethical implications of research software (energy consumption,
        social engineering etc.)
      \item
        mathematical (high) performance computing
      \item
        neighbouring computational science fields (data science,
        research data management \ldots)
      \item
        the role of simulation modelling in scientific practice
      \item
        software requirements in the research context
      \item
        numerical methods and high performance computing
      \item
        statistics and machine learning methods
      \item
        reproducibility hackathon practical course
      \item
        the scientific method, epistemology and ethics
      \item
        interpersonal competencies
      \item
        the open source software community of practice
      \item
        distributed research infrastructure technologies
      \end{itemize}
    \item
      software engineering foundation and required computer science
      modules, e.g.

      \begin{itemize}
      \tightlist
      \item
        software architecture and design
      \item
        database and information systems
      \item
        computer architecture
      \item
        distributed systems
      \item
        software engineering operations
      \item
        software construction
      \item
        practical software engineering project
      \end{itemize}
    \item
      specialization in their original natural science domain

      \begin{enumerate}
      \def\labelenumii{\alph{enumii}.}
      \tightlist
      \item
        exemplary specialization in theoretical particle physics
      \end{enumerate}

      \begin{itemize}
      \tightlist
      \item
        quantum field theory
      \item
        elementary particle physics
      \item
        particle detector design
      \item
        further lab work (e.g.~electronics labs),
      \item
        elective course for example from string theory, group theory,
        general relativity
      \end{itemize}

      \begin{enumerate}
      \def\labelenumii{\alph{enumii}.}
      \setcounter{enumii}{1}
      \tightlist
      \item
        exemplary specialization in computational biology
      \end{enumerate}

      \begin{itemize}
      \tightlist
      \item
        applied cell and molecular biology
      \item
        quantitative genetics
      \item
        quantitative cell and molecular biology laboratory
      \item
        genomics
      \item
        statistical genetics
      \end{itemize}
    \end{enumerate}

    This set of skills makes the RSE a professional who is able to take
    a set of equations from a modern theory, implement them reliably and
    reusable and lead an interdisciplinary team to create and maintain a
    successful software-project for the academic world around it.

    \section{Conclusion}\label{conclusion}

    Natural Sciences have a long history of using computing devices in
    order to enhance the predictive power of their theories. But in
    order to move the frontiers of knowledge, inspired individuals in
    the natural sciences often work and innovate outside of standard
    operating procedures. With the advent of the computer, the
    subliminal application of techniques and technologies from SE has
    been sufficient in the recent past up to the present, to improve the
    efficiency of these individual scientists creating software. But the
    availability of ever more computing resources will require a control
    of the complexity of deeper technology stacks and it will require
    larger forms of organisation in order to drive progress in the
    natural sciences forward in the future. Combined with external
    pressures to making Research Software FAIR we expect also in the
    natural sciences a transition to more structured development
    processes. In order to be prepared for these changes we argue that a
    new job profile is necessary. While the generic Research Software
    Engineer is already meant to work at this intersection of research
    and Software Engineering, succesful work in the natural sciences
    poses additional challenges. The inherent complexity of the domain
    requires a deep knowledge in the domain, and collaboration in teams
    of scientists is only facilitated by a respective knowledge of the
    domains culture. We argue that in order to address this challenge, a
    unique identity is needed for these professionals, and by extension
    then requires a specialized Master's degree that builds upon a
    domain bachelor. This RSE-Master for the natural sciences will then
    combine the hard domain science with software engineering training
    and modules that address key RSE issues, enabling them to work in or
    lead highly specialized teams of scientists.

    Being at home in a natural science \emph{and} in Software
    Engineering the RSE in the Natural Sciences is located perfectly to
    move science to a level of managing complexity of software project
    structures that would probably not be possible without SE alone.

\paragraph{Copyright.}

Mit der Übersendung Ihres Beitrags an uns erteilen Sie uns gleichzeitig die Erlaubnis,
den Beitrag in den \stt\ abzudrucken. Wir unterstellen, dass Sie hierzu berechtigt sind.
Sofern Ihr Beitrag Bilder, Textpassagen oder andere Teile enthält, deren Copyright
von einer dritten Instanz gehalten wird, sind Sie dafür verantwortlich,
entsprechende Genehmigungen zum Abdruck zu beschaffen.


\printbibliography

\end{document}




