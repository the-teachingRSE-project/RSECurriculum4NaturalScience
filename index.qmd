---
title: "Research Software Engineering for Natural Sciences"
author:
  - name: Julian Dehne
    affiliation: GI
    orcid: 0000-0001-9265-9619
    index: 1
  - name: Simon Christ
    affiliation: Leibniz University Hannover, Department of Cell Biology and Biophysics, Computational Biology, Germany
    orcid: 0000-0002-5866-1472
    index: 2
  - name: Florian Goth
    affiliation: Würzburg-Dresden Cluster of Excellence ct.qmat, University of Würzburg, 97074, Würzburg, Germany
    orcid: 0000-0003-2707-4790
    index: 3
  - name: Jean-Noël Grad
    affiliation: Institute for Computational Physics, University of Stuttgart, Germany
    index: 4
    orcid: 0000-0002-5821-4912
  - name: Magnus Hagdorn
    affiliation: Geschäftsbereich IT, Charité Universitätsmedizin Berlin, Germany
    orcid: 0000-0002-5076-4864
    index: 5
  - name: Jan Philipp Thiele
    affiliation: Technische Universität Braunschweig, Germany
    orcid: 0000-0002-2755-5087
    index: 6
  - name: Harald von Waldow
    affiliation: Johann Heinrich von Thünen Institute, Centre for Information Management, Germany
    orcid: 0000-0003-4800-2833
    index: 7

format:
    pdf:
        template: quarto-swt-template.tex
        classoption: [twocolumn, german, biblatex]
        cite-method: biblatex
        keep-tex: true
        pdf-engine: pdflatex
        biblio-style: lni
        bibliography: my-paper.bib
        include-in-header:
        - text: |
            $highlighting-macros$
        tables:
            longtable: false
editor: 
  markdown: 
    wrap: 72
---

# Introduction

The term Research Software Engineer (RSE) has become a label
for specific technical job roles in universities and research institutions.
It relates to people doing work that includes elements of traditional software engineering
but also rests on a broad spectrum of skills from neighbouring domains
such as scientific computing, data science, research data management, and the open science movement in general
as well as skills that have not been packaged into elements of established curricula in formal education yet.

Software engineering as a discipline has evolved, over the past four decades,
into a mature field with a large body of knowledge that includes
methods, theory, codes of practice and well developed sub-fields.
Established curricula in degree programs produce practitioners of a well defined engineering profession.


Although researchers have used computers in scientific work since the dawn of the computing era, the formal role of Research Software Engineer (RSE) has only recently been recognized. Nevertheless, the RSE community largely comprises individuals without formal education in software engineering.
However, it has been realized that the increasing importance of
computational science, complexity, demands, size of teams, number of collaboration partners
and generally the need for more ambitious software projects
calls for a better and more systematic reuse of knowledge and skills from software engineering.
This is especially true for natural sciences (from here on "sciences"),
where RSEs' expertise often focuses on very specialized technical
problem-solving in close conjunction with a specific research question
at the expense of the mastery of more general concepts of software engineering.

A disconnect between scientific computing and software engineering
practitioners and communities has been already observed by @Kelly2007.
We aim to improve the situation in the spirit of her conclusion,
which urges the scientific community to better apply the current solutions
offered by the software engineering community and the latter to better cater
to the sciences as an application domain.
Thus, the idea of introducing a master curriculum for research software engineering for natural sciences was born.
Establishing this formal training in Research Software engineering(RSEng) will raise specialists that can fill a vacuum for computational specialists in the sciences.
On the one hand, those RSEs should be firmly grounded in software engineering and assume practices and the mindset of a software engineer.
On the other hand, these RSEs should develop a deep understanding of computational scientific work and the relevant methods and practices.
They should assume a specific professional identity that also includes the self-image of a scientist with the associated values and practices, functions and is recognized as an equal member of a domain research team.

The research question of this paper is "What is the identity needed for
students to be accepted and feel as qualified software engineers
but also be  intellectually connected to the natural sciences?". In other
words: what is the special relationship between natural sciences and
computing historically, and how does it relate to software engineering
foundations. In order to answer this question the paper is structured as
follows: (1) the history of natural science and computing (2) the
history of software engineering as it relates to research. (3) What
is the common core that should be the identity of a research software
engineer? (4) How does the ideal identity of a research software engineer
inform the planned curriculum for research software engineering?

Similar efforts were carried out in allied communities and have yielded tailored curricula,
such as the RSE-HPC curriculum [@Filinger2025] by the UNIVERSE-HPC project,
the RSE curriculum for computer scientists [@Chourdakis2025] at the Technical University of Munich,
the Simulation Software Engineering course [@Uekermann2021] at the University of Stuttgart,
or the Bachelor's and Master's program "Simulation Technology" from the Cluster
of Excellence "Data-Integrated Simulation Science (SimTech)" [@SimTech2019]
for computer science students.
An RSE for Natural Sciences curriculum would help professionalize RSE career
paths in natural sciences, while also addressing the specific needs of scientists,
such as accumulating enough academic credit in natural sciences to be able to
enroll in a Ph.D. program in a STEM field.

Such a curriculum would also be of interest to train natural science Ph.D. candidates
in specific aspects of SE and RSE practices relevant to their software applications,
while also receiving academic credit through their graduate school.

Historically, natural sciences and software engineering share common threads in the fabric of their identities,
but different challenges in the past decades have led to an estrangement between the fields.
Today students of one field can not easily cross over into the other field and contribute their knowledge,
due to the different domain identites that have been forged.

Here we argue that it is not enough to augment a software engineering curriculum with a specialization in a natural science
or to add or improve the computer programming modules in a science curriculum.
We propose that it is necessary to create a set of new disciplines that more fundamentally fuse software engineering with a natural science.
A discipline of this kind, e.g. "Research Software Engineering in Earth Science", should be more than a combination of both fields.
It should rather assume its own distinct identity
and generate new research questions, new methods to address them,
and a new type of expert to substantially re-shape and advance relevant scientific sub-domains, e.g. climate system modeling.
This goal should form the basis for creating new  master's programs that lay the foundation for students to assume a professional identity as Research Software Engineers in Science.
It should make them qualified Software Engineers as well as fully accepted scientists in a natural science, who feel intellectually at home in both domains.

To further explore this proposition we first briefly review
the history of natural sciences and computing
as well as the history of software engineering as it relates to research.
We then identify challenges that currently define the identity research software engineers and
conclude how these challenges and the RSE-identity could inform a future curriculum for Research Software Engineering for Natural Science.

# What is the history of natural science and computing?

_Here we explain, why Natural sciences and means of computation are
linked _

TODO: check if the content is still valid after rephrasing it with AI
for the purpose of this paper:

From their origins in the Renaissance, the natural sciences have been
intertwined with computation. Early pioneers like Kepler and
Galileo not only measured natural phenomena but sought mathematical laws
to describe them—laws that enabled prediction. This marked the beginning
of a fundamental trait of natural science: the drive to quantify and
predict nature, constrained only by the available means of computation.

Throughout history, computational tools—from early mechanical
calculators like Pascal’s Pascaline to Babbage’s visionary Analytical
Engine—emerged alongside the growing ambitions of science [@bromley2008charles].

In the 20th century, particularly during World War II, modern computing
was born out of scientific necessity. Machines like Zuse’s Z3 in Germany
[@Zuse1986], the British COLOSSUS [@Copeland2004], and the American
ENIAC [@Burks1981] were built not only to support military operations
but also to solve scientific and engineering problems of increasing
complexity.

This wartime acceleration of computation laid the groundwork for the
post-war integration of computing into everyday scientific practice. The
development of high-level programming languages like FORTRAN by John
Backus and his team at IBM [@Backus1978] enabled scientists to express
algorithms independently of hardware, transforming how they interacted
with computation.

By the 1960s, with the advent of the CDC 6600—the first
supercomputer—designed by Seymour Cray [@Kaufmann1994], computation had
become central to the scientific method. Vectorized processors and
increasing speed meant that simulation and modeling could now
complement, and sometimes replace, physical experimentation.

Computation has since permeated nearly every field of natural science,
often giving rise to entire sub-disciplines such as:

-   Chemistry: computational chemistry
-   Physics: computational physics, especially astrophysics
-   Physical chemistry: cheminformatics
-   Biology: bioinformatics, biostatistics, computational biology,
    computational bio-modeling
-   Medicine: digital medicine, computer-aided drug design
-   Earth science: weather forecasting, Earth system modeling (climate,
    ocean, cryosphere, landscape), magneto-hydrodynamic simulation of
    the Earth’s core, geo-electric simulations, seismic processing, and geographic information systems
    (GIS)

Today, at least some computational skills are needed in most fields of natural sciences.
The development of computational tools is not just a support activity;
it defines how science is practiced, scaled, and extended.

# A small History of Software Engineering and Research Applications

_Here we explain, where Software Engineering comes from, and where
and why it deviated from its co-development with science_

After the second World War the Apollo Program was a major driver in
enhancing the quality of mission-critical software. (TODO: We could mention Margaret Hamilton, as the first person identifying herself as a "software engineer".)
In this setting the term 'software engineering' was coined[@Randell1979]
and two well-known NATO conferences were held in 1968[@Naur1969] and
1969[@Buxton1970] to discuss how to keep software projects reliable and in time.
While good programming practices were already circulating as soon as 1961[@Hosier1961],
these NATO conferences shed light on the 'software crisis'[@Randell1979].
Adoption of best coding practices was slow[@Boehm1979], with calls to reform
not just programming techniques but also programming culture[@Weinberg1971; @Boehm1979],
e.g. by promoting software documentation and teamwork over lone coders
with full knowledge of the codebase[@Weinberg1971, p. 100]
(with an early formulation[@Weinberg1971, p. 114] of what is now known
as the 'bus factor'[@Zazworka2010; @Jabrayilzade2022]).
The notion of the quality and reliability of software
continued to be a driving force of software engineering with the
ever-increasing use of software in safety-critical systems
(e.g. medicine or aviation), which meant that software could kill, in the 70s and 80s.
The next big projects was the development of modern general purpose
operating systems in the late 80s, which combined with affordable
personal computers, helped democratize the use and development of
research software for lab instrument control, data acquisition,
and statistical analysis[@Robinson1984].
The advent of the Internet added another level of complexity,
since new modes of operation for software across multiple computers are possible.
In 2005, the Software Engineering Body of Knowledge (SWEBOK) was created
to document foundational competencies of SEs[@SWEBOK2005]
and design academic curricula[@Fairley2014].

In the 2000s, the SE community identified a special case of software users nicknamed
'professional end-user developers'[@Segal2005; @Segal2007; @Segal2009b].
Most of the interviews were conducted with scientists and revealed the difficulties
of reconciling research practices with software engineering practices[@Segal2005; @Segal2009; @Lawrence2006; @Wood2003; @Storer2017].
In parallel, science communities also identified a new role centered around research software[@Baxter2006],
although the term 'research software engineer' wouldn't be coined until 2012[@Baxter2012].

# Research Software Engineering for Natural Sciences

_Here we look forward to the challenges for (natural) science and
why we can only move forward by putting more emphasis on SE techniques, _

XXXXXXX bis hier XXXXXXXXXXXXXXXXXXXXXXX
XXXXXXX Übergang XXXXXXXXXXXXXXXXXXXXXXX

Classical software engineering and computing for the sciences have drifted apart
as some influencing factors have developed differently over time.
These differences can be illustrated with (at least three) structural dichotomies:

- fast prototyping / short term  vs. long-term software growth
- internalized knowledge vs. externalized knowledge
- mathematically-driven modelling vs. human-driven modelling

[Story being told here: Lack of overlap SE / RSE cause by software often one-shot, for personal growth (qualification) as opposed to growth of organization]
Most research in academia[find citation that shows 70% of output is generated by PhDs] is usually driven by individuals that often do their research
in order to a achieve a personal qualification goal, such as a PhD.
This leads to a set of intermingling goals, on the hand there is the personal qualification goal, that has to be achieved in a given time-scale
in order to move on, on the other hand there are goals of the organisation.
And let us not forget, that scientific academic culture is characterized by a rapidly changing environment and a pressure to publish frequently.
This web of goals leads to certain aspects that are peculiar to software development in academia.
First, software is often developed and maintained only during a single PhD project.
Instead of prototyping in order to prepare a blueprint that a larger team of engineers can use to build a well-designed and sound product, research-oriented software hence often remains in the prototype stage.
Therefore, duplication of effort, or "reinventing the wheel", has been documented in research software [@Smith2024].
To counteract this trend, funding agencies have created incentives to consolidate fragmented domain codes by prioritizing research software
that is easily extensible and re-usable in different contexts with minimally-invasive adaptations [@DFG2022RSE].

The rapidly changing environment in academia requires flexible processes.
This need for flexibility in scientific software development in principle lends itself ideally to the application of agile methods.
Therefore, this situation calls for an injection of professional SE-Know-How in that area.
However, the traditional agile development methodologies (Scrum, Kanban,.. ) are usually presented for large team and large industry-style projects.
An adaption of these practices to small and even one-person teams would be a useful part of an RSE4NatSci-curriculum.
This specific case shows that SE techniques in general cannot be applied to the research context without adaptions.

(TODO: From my perspective, this part needs more elaboration. Also, I'm personally hesitant about our stance regarding the use of abstraction. I searched for "abstraction" in @Lawrence2006, but did not succeed in finding the respective statement. However, maybe what we want to say here is more in a sense of: Software engineering techniques often rely on the use of abstractions to achieve modularity, maintainability, and scalability in complex systems. On the other hand, in research software, the overhead introduced by additional abstraction layers can be challenging for developers not familiar with the techniques. Hence, the additional complexity sometimes hinder rapid prototyping and direct implementation of domain-specific algorithms, especially when developer teams are small and focused on immediate scientific goals.)
In addition, many principles of software engineering (i.e. separation of concerns, service orientation, \ldots)
support long term sustainable growth of software systems which is a relevant factor in market-driven industries [find literature].
However, abstractions can lead to overhead for small developer teams typical to research contexts [@Lawrence2006].

Another aspect that distinguishes the typical software process design from research software engineering is the ambition of externalizing all knowledge that is contained in the software.
In an industrial setting where bottlenecks are a problem and programmers need to be replaceable this is an essential factor of effectiveness [@gronau2006kmdl].
In the natural sciences, application code is often based on state-of-the-art mathematical models that are only accessible to very few specialized researchers.
Here, the question arises if the mathematical model should be considered the documentation whereas the software only plays the role of proof-of-concept implementations.

A similar argument could be made for systematics of software engineering processes and management.
Modelling user behavior introduces a set of new complexities that lead to the development of management techniques such as agile development that try to expose the software to the customers as often as possible in order to adapt the software more efficiently to the user. From requirements engineering, to prototyping and evaluation, the social sciences and psychology have played a role in connecting craftsmanship of an engineer to the intricacies of big human teams, customers and stakeholders [find something that talks about human computer interaction and software engineering]. Only recently have research software teams and research groups grown to an extent that these insights are needed [todo reference for claim].

[Adaptions needed III ]
However, abstractions can lead to overhead for small developer teams typical to research contexts [@Lawrence2006].

[Some SE processes are not applicable in NatSci]
From requirements engineering, to prototyping and evaluation, the social sciences and psychology have played a role in connecting craftsmanship of an engineer to the intricacies of big human teams, customers and stakeholders [find something that talks about human computer interaction and software engineering.

[Some SE topics should be taken up by RSEs4NatSci unchanged]
SOLID principles, design patterns, .....



# A RSE Master Curriculum

Taking the historical trend into consideration it becomes apparent that the traditional division of labor between software engineers and computational scientists is no longer appropriate for today's challenges.
As Research Software Engineering starts to combine software engineering and science again, therby reversing the historical trend, the question arises which disciplinary identity a research software engineer should have.

We argue that neither additional traing in a natural science for software engineers nor vice versa would be suited for the development of an adequate professional identity. For example an SE-curriculum augmented with physics courses within the typical timeframe alloted for a masters degree will not be sufficent for a student to accumulate the exposure, knowledge and experience necessary to develop a physicist's identity in addition to her SE identity. As @gomez2025 observe, a new discipline is required for a new professional identity aquired through formal academic education.

Similar to data scientists, data stewards and other modern job roles, a research engineer for the natural sciences is not a niche innovation based on a short-living trend.
The newly formed identity should encompass key competences from both fields, be rooted in the history and culture of both SE and natural sciences while including new competencies that arise from the special requirements for typical RSE work.

We proposed a rough outline for a masters curriculum in Research Software Engineering for Natural Science that is suited for students with a Bachelor degree in a natural science.
Based on the previous discussion and workshops with the RSE-community [add citation to deRSE] the curriculum should contain three parts. In order to detail this curriculum in a domain specific manner, we consider the example of a Bachelor of Physics, who enrolls in a master program "Research Software Engineering for Physics" who specializes in theoretical particle physics.

If neither division of labor between software engineers and scientists, nor an additive training to be both work conceptually, the third option is to develop a new identity and a corresponding professional field.
Similar to data scientists, data stewards and other modern job roles, a research engineer for the natural sciences is not a niche innovation based on a short-living trend. The newly formed identity should encompass the history, culture and key competences from both fields.

Based on the previous discussion and workshops with the RSE-community [@derseev] the curriculum should contain these parts:

1. software engineering foundation and required computer science modules
2. a firm background in natural science methods (Math and domain specific modules)
3. an identity building group of modules that addresses key RSE issues such as ...
   - history of software engineering in science [@leroy_when_2021]
   - research software science [@felderer_investigating_2025;@heroux_research_2022]
   - management and communication in the research context
   - ethical implications of research software (energy consumption, social engineering etc.)
   - mathematical (high) performance computing
   - neighbouring computational science fields (data science, research data management ...)
   - the role of simulation modelling in scientific practice
   - software requirements in the research context
   - numerical methods and high performance computing
   - statistics and machine learning methods
   - reproducibility hackathon practical course
   - the scientific method, epistemology and ethics
   - interpersonal competencies
   - the open source software community of practice
   - distributed research infrastructure technologies
4. software engineering foundation and required computer science modules, e.g.
   - software architecture and design
   - database and information systems
   - computer architecture
   - distributed systems
   - software engineering operations
   - software construction
   - practical software engineering project
5. specialization in their original natural science domain 
   a. exemplary specialization in theoretical particle physics
     - quantum field theory
     - elementary particle physics
     - particle detector design
     - further lab work (e.g. electronics labs),
     - elective course for example from string thory, group theory, general relativity
   b. exemplary specialization in computational biology
     - applied cell and molecular biology
     - quantitive genetics
     - quantitive cell and molecular biology laboratory
     - genomics
     - statistical genetics

This set of skills makes the RSE a professional who is able to take a set of
equations from a modern theory, implement them reliably and reusably and lead an interdisciplinary team to create and maintain a successful software-project for the academic world around it.

# Conclusion

Natural Sciences have a long history of using computing devices in order to enhance the predictive power of their theories.
But in order to move the frontiers of knowledge, inspired individuals in the natural sciences often
work and innovate outside of standard operating procedures.
With the advent of the computer, the subliminal application of techniques and technologies
from SE has been sufficient in the recent past up to the present,
to improve the efficiency of these individual scientists creating software.
But the availability of ever more computing resources will require a control
of the complexity of deeper technology stacks and it will require larger forms
of organisation in order to drive progress in the natural sciences forward in the future.
Combined with external pressures to making Research Software FAIR we expect also in the natural sciences a transition to
more structured development processes.
The RSE in the Natural Sciences being at home in a natural science *and* in Software Engineering is located perfectly
to move science to a level of managing complexity of software project structures that would probably not be possible without SE alone.
