---
title: "Research Software Engineering Competences for Natural Sciences"
author: ["Max Mustermann"]
format:
    pdf:
        template: quarto-swt-template.tex
        classoption: [twocolumn, german, biblatex]
        cite-method: biblatex
        keep-tex: true
        pdf-engine: pdflatex
        biblio-style: lni
        bibliography: my-paper.bib
        include-in-header:
        - text: |
            $highlighting-macros$
        tables:
            longtable: false
---



# Introduction

The term Research Software Engineer, or RSE,
emerged a little over 10 years ago as a way to represent
individuals working in the research community but focusing on software development.
The term has been widely adopted and there are a number of high-level definitions of what an RSE is.
However, the roles of RSEs vary depending on the institutional context they work in.
At one end of the spectrum, RSE roles may look similar to a traditional research role.
At the other extreme, they resemble that of a software engineer in industry.
Most RSE roles inhabit the space between these two extremes.

For the purpose of creating an RSE-Master Programm we identify the RSE as a person who
creates or improves research software and/or the structures that the software interacts with
in the computational environment of a research domain.
In this spectrum we see skilled team member who may also choose to conduct own research as part of their role.
But on the other end we also see paths for an RSE to specifically focus on a technical
role as an alternative to a traditional research role
because they enjoy and wish to focus on the development of research software.

For this task, to support research with/in the creation of digital tools,
we structure this sample curriculum along three pillars:

- research skills: these are competencies that enable an RSE to effectively participate in the research domain.
- technical skills: these are competencies, that enable an RSE to create effective tools for research
- communication skills: these are skills that enable an RSE to effectively work and communicate with its peers and stakeholders across multiple domains.

The RSE curriculum is based on previous work of the deRSE community such as [@Goth2024RSE].


## What is the history of natural science and computing?

Empirical natural sciences trace its roots back to the renaisance where philosophers like Francis Bacon 
and then scientists like Kepler and Gallileo who actually first measured the behaviour of the natural world and then tried to find 
quantifiable laws from them, giving us e.g. the Keplerian laws.
Having these laws it became possible to do quantifiable predictions about the behaviour of systems.
What this also means, that the quality and complexity of these predictions is always inextriably linked 
to the computational power at hand, thereby linking the advancement of modern science and engineering together with the development of humanities computational tools.

Computing devices existed since the antiquity and are not inventions of the 20th century. Two
of the more famous examples are Blaise Pascal’s "Pascaline" and, of
course, Charles Babbage’s proposed, but never finished, "Analytical
engine". The "Analytical engine" would have been the first mechani-
cal general-purpose computer. Monte Carlo experiments do also date
a bit farther back in time and were already done before computers
were available, e. g. Buffon’s needle, but it was usually impractical to 
perform the huge number of simulations required to apply statistical
methods. Sharing a similar fate as many other inventions of the 20th
century the electronic computer was conceived in those dark years
of World War II, giving us a good point in time that we can use to
locate the beginning of super-computing and modern Monte Carlo
methods. 
The first computers emerged then independently in the 1940s in Germany, the United Kingdom and the United States.
The electro-mechanical Z3 developed by Konrad Zuse in 1941 to solve a complex matrix describing flutter of aeroplane wings ([@Zuse1986]).
But not only geographical borders were rearranged during
the second World War. In a continuation of the first World War, the
scientific community was enlisted into the services of the opponents’
military forces. Taken together with the massive scale of the war, this
meant that the huge computational efforts on all sides created a de-
mand for the development of faster means of computation. One ex-
ample is given by specialized devices for encryption and decryption
of messages. This there-
fore led to the construction of specialized computation devices, as e.g.
the COLOSSUS, the first electronic, limited programmable machine
In the UK Tommy Flowers developed the Colossus computer in 1943.
The Colossi use valves to decypher German encrypted messages ([@Copeland2004]).
In the US the ENIAC, also a computer using valves, was designed by John Mauchly and J. Presper Eckert.
It was initially developed to calculate artillery firing tables but was used to compute the feasibility of the thermonuclear weapon ([@Burks1981]).
All three systems were developed to support military research.

The programs of early computers were either hardwired (Colossus) or programmed using machine code.
Grace Hopper developed the first compiler that translated a program written in a more easily understood language to machine code understood by a computer.
This development allowed the separation of of algorithm expressed in the program from the computer hardware on which that program should run.
The programming language FORTRAN was developed at IBM by a team led by John Backus in the early 1950s.
The first FORTRAN compiler was released in 1957 ([@Backus1978]).
FORTRAN was easy to learn and allowed scientists and engineers to develop programs that solve mathematical problems arising for example in physics or material sciences.

In 1964 the CDC 6600 designed by Seymour Cray was released. 
It is considered to be the first supercomputer with a performance of up to 9MFLOPS ([@Kaufmann1994]). 
Cray continued to dominate the supercomputing market by designing an producing a new kind of processor architecture which can perform vectorised computations.


## What are science-specific RSE competencies?



## What are existing fields that can be grouped under this header?

* Chemistry
   * computational chemistry
* Physics
   * computational physics
   * computational astrophysics
* Physical chemistry
   * cheminformatics
* Biology
   * bioinformatics
   * biostatistics
   * computational biology
   * computational biomodeling
* Medicine
   * digital medicine
* Earth science
   * climate modeling
   * computational oceanography
   * geographic information system

TODO: Is there a common denominater in terms of typical 

- problems
- processes
- methods/algorithm classes?

TODO: Can we map this to "Forschungsformen" from the Wissenschaftsrat? Portray this as a single graphic or something?



## How are the sciences different from other fields in terms of RSE requirements?

## What are science-specific RSE jobs?


## What should a MNT_RSE-Curriculum should look like?

This we can import from the Curriculum Project.
